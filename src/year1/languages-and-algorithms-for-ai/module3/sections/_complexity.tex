\chapter{Complexity}


\begin{description}
    \item[Complexity class] \marginnote{Complexity class}
        Set of tasks that can be computed within some fixed resource bounds.
\end{description}



\section{Polynomial time}

\begin{description}
    \item[Deterministic time (\DTIME)] \marginnote{Deterministic time (\DTIME)}
        Let $T: \mathbb{N} \rightarrow \mathbb{N}$ and $\mathcal{L}$ be a language.
        $\mathcal{L}$ is in $\DTIME(T(n))$ iff
        there exists a TM that decides $\mathcal{L}$ in time $O(T(n))$.

    \item[Polynomial time (\P)] \marginnote{Polynomial time (\P)}
        The class \P contains all the tasks computable in polynomial time:
        \[ \P = \bigcup_{c \geq 1} \DTIME(n^c) \]

        \begin{remark}
            \P is closed to various operations on programs (e.g. composition of programs)
        \end{remark}

        \begin{remark}
            In practice, the exponent is often small.
        \end{remark}

        \begin{remark}
            \P considers the worst case and is not always realistic.
            Other alternative computational models exist.
        \end{remark}
    
    \item[Church-Turing thesis] \marginnote{Church-Turing thesis}
        Any physically realizable computer can be simulated by a TM with an arbitrary time overhead.

    \item[Strong Church-Turing thesis] \marginnote{Strong Church-Turing thesis}
        Any physically realizable computer can be simulated by a TM with a polynomial time overhead.

        \begin{remark}
            If this thesis holds, the class \P is robust 
            (i.e. does not depend on the computational device)
            and is therefore the smallest class of bounds.
        \end{remark}

    \item[Deterministic time for functions (\FDTIME)] \marginnote{Deterministic time for functions (\FDTIME)}
        Let $T: \mathbb{N} \rightarrow \mathbb{N}$ and 
        $f: \{0, 1\}^* \rightarrow \{0, 1\}^*$.
        $f$ is in $\FDTIME(T(n))$ iff
        there exists a TM that computes it in time $O(T(n))$.

    \item[Polynomial time for functions (\FP)] \marginnote{Polynomial time for functions (\FP)}
        The class \FP is defined as:
        \[ \FP = \bigcup_{c \geq 1} \FDTIME(n^c) \]
        
        \begin{remark}
            It holds that $\forall \mathcal{L} \in \P \Rightarrow f_\mathcal{L} \in \FP$,
            where $f_\mathcal{L}$ is the characteristic function of $\mathcal{L}$.
            Generally, the contrary does not hold.
        \end{remark}
\end{description}



\section{Exponential time}

\begin{description}
    \item[Exponential time (\EXP/\FEXP)] \marginnote{Exponential time (\EXP/\FEXP)}
        The \EXP and \FEXP classes are defined as:
        \[
            \EXP = \bigcup_{c \geq 1} \DTIME\big( 2^{n^c} \big) \hspace{3em} 
            \FEXP = \bigcup_{c \geq 1} \FDTIME\big( 2^{n^c} \big)
        \]

        \begin{theorem}
            The following hold:
            \[ \P \subset \EXP \hspace{3em} \FP \subset \FEXP \]
        \end{theorem}
\end{description}



\section{\NP class}

\begin{description}
    \item[Certificate] \marginnote{Certificate}
        Given a set of pairs $\mathcal{C}_\mathcal{L}$ and a polynomial $p: \mathbb{N} \rightarrow \mathbb{N}$, 
        we can define the language $\mathcal{L}$ such that:
        \[ \mathcal{L} = \{ x \in \{0, 1\}^* \mid \exists y \in \{0, 1\}^{p(\vert x \vert)}: (x, y) \in \mathcal{C}_\mathcal{L} \} \]

        Given a string $w$ and a certificate $y$,
        we can exploit $\mathcal{C}_\mathcal{L}$ as a test to check whether $y$ is a certificate for $w$:
        \[ w \in \mathcal{L} \iff (w, y) \in \mathcal{C}_\mathcal{L} \]

    \item[Nondeterministic TM (NDTM)] \marginnote{Nondeterministic TM (NDTM)}
        TM that has two transition functions $\delta_0$, $\delta_1$ and, at each step, non-deterministically chooses which one to follow.
        A state $q_\text{accept}$ is always present:
        \begin{itemize}
            \item A NDTM accepts a string iff one of the possible computations reaches $q_\text{accept}$.
            \item A NDTM rejects a string iff none of the possible computations reach $q_\text{accept}$.
        \end{itemize}

    \item[Nondeterministic time (\NDTIME)] \marginnote{Nondeterministic time (\NDTIME)}
        Let  $T: \mathbb{N} \rightarrow \mathbb{N}$ and $\mathcal{L}$ be a language.
        $\mathcal{L}$ is in $\NDTIME(T(n))$ iff
        there exists a NDTM that decides $\mathcal{L}$ in time $O(T(n))$.

        \begin{remark}
            A NDTM $\mathcal{M}$ runs in time $T: \mathbb{N} \rightarrow \mathbb{N}$ iff
            for every input, any possible computation terminates in time $O(T(n))$.
        \end{remark}
    
    \item[Complexity class \NP] \marginnote{Complexity class \NP}
        \phantom{}
        \begin{description}
            \item[NDTM formulation] 
                The class \NP contains all the tasks computable in polynomial time by a nondeterministic TM:
                \[ \NP = \bigcup_{c \geq 1} \NDTIME(n^c) \]

            \item[Verifier formulation] 
                Let $\mathcal{L} \in \{0, 1\}^*$ be a language.
                $\mathcal{L}$ is in \NP iff there exists 
                a polynomial $p: \mathbb{N} \rightarrow \mathbb{N}$ and 
                a polynomial TM $\mathcal{M}$ (verifier) such that:
                \[ \mathcal{L} = \{ x \in \{0, 1\}^* \mid \exists y \in \{0, 1\}^{p(\vert x \vert)}: \mathcal{M}(\enc{(x, y)}) = 1 \} \]
        
                In other words, $\mathcal{L}$ is the language of the strings that can be verified by $\mathcal{M}$ in polynomial time
                using a certificate $y$ of polynomial length.
        \end{description}
        
\end{description}

\begin{theorem} \label{th:P_NP_EXP_relationship}
    $\P \subseteq \NP \subseteq \EXP$.

    \begin{proof}
        We have to prove that $\P \subseteq \NP$ and $\NP \subseteq \EXP$:
        \begin{description}
            \item[$\P \subseteq \NP$)] 
                Given a language $\mathcal{L} \in \P$, we want to prove that $\mathcal{L} \in \NP$.
                
                By hypothesis, there is a polynomial time TM $\mathcal{N}$ that decides $\mathcal{L}$.
                To prove that $\mathcal{L}$ is in $\NP$, 
                we show that there is a polynomial verifier $\mathcal{M}$ that certifies $\mathcal{L}$ with a polynomial certificate.
                We can use any constant certificate (e.g. of length 1) and 
                use $\mathcal{N}$ as the verifier $\mathcal{M}$:
                \[  
                    \mathcal{M}(x, y) = \begin{cases}
                        1 & \text{if $\mathcal{N}(x) = 1$} \\
                        0 & \text{otherwise}
                    \end{cases}    
                \]
                $\mathcal{M}$ can ignore the polynomial certificate and it "verifies" a string in polynomial time through $\mathcal{N}$.
            
            \item[$\NP \subseteq \EXP$)]
                Given a language $\mathcal{L} \in \NP$, we want to prove that $\mathcal{L} \in \EXP$.
                
                By hypothesis, there is a polynomial time TM $\mathcal{N}$ that is able to certify any string in $\mathcal{L}$ with a polynomial certificate.
                Given a polynomial $p$, can define the following algorithm:
                \begin{lstlisting}[mathescape=true]
                    def np_to_exp($x \in \{0, 1\}^*$):
                        foreach $y \in \{0, 1\}^{p(\vert x \vert)}$:
                            if $\mathcal{M}(x, y) == 1$:
                                return 1
                        return 0
                \end{lstlisting}
                The algorithm has complexity 
                $O(2^{p(\vert x \vert)}) \cdot O(q(\vert x \vert + \vert y \vert)) = O(2^{p(\vert x \vert) + \log(q(\vert x \vert + \vert y \vert))})$,
                where $q$ is a polynomial.
                Therefore, the complexity is exponential.
        \end{description}
    \end{proof}
\end{theorem}


\begin{description}
    \item[Polynomial-time reducibility] \marginnote{Polynomial-time reducibility}
        A language $\mathcal{L}$ is poly-time reducible to $\mathcal{H}$ ($\mathcal{L} \leq_p \mathcal{H}$) iff:
        \[ 
            \begin{split}
                \exists f: \{0, 1\}^* \rightarrow \{0, 1\}^* \text{ such that } &(x \in \mathcal{L} \iff f(x) \in \mathcal{H}) \text{ and} \\
                &\text{$f$ is computable in poly-time}
            \end{split}
        \]
        $f$ can be seen as a mapping function.

        \begin{remark}
            Intuitively, when $\mathcal{L} \leq_p \mathcal{H}$, $\mathcal{H}$ is at least as difficult as $\mathcal{L}$.
        \end{remark}

        \begin{theorem}
            The relation $\leq_p$ is a pre-order (i.e. reflexive and transitive).

            \begin{proof}
                We want to prove that $\leq_p$ is reflexive and transitive:
                \begin{descriptionlist}
                    \item[Reflexive)] 
                        Given a language $\mathcal{L}$, we want to prove that $\mathcal{L} \leq_p \mathcal{L}$.
                        
                        We have to find a poly-time function $f: \{0, 1\}^* \rightarrow \{0, 1\}^*$ such that:
                        \[ x \in \mathcal{L} \iff f(x) \in \mathcal{L} \]
                        We can choose $f$ as the identity function.

                    \item[Transitive)] 
                        Given the languages $\mathcal{L}, \mathcal{H}, \mathcal{J}$, we want to prove that:
                        \[ (\mathcal{L} \leq_p \mathcal{H}) \land (\mathcal{H} \leq_p \mathcal{J}) \Rightarrow (\mathcal{L} \leq_p \mathcal{J}) \]

                        By hypothesis, it holds that $\mathcal{L} \leq_p \mathcal{H}$ and $\mathcal{H} \leq_p \mathcal{J}$.
                        Therefore, there are two poly-time functions $f, g: \{0, 1\}^* \rightarrow \{0, 1\}^*$ such that:
                        \[ x \in \mathcal{L} \iff f(x) \in \mathcal{H} \text{ and } y \in \mathcal{H} \iff f(y) \in \mathcal{J} \]
                        We want to find a poly-time mapping from $\mathcal{L}$ to $\mathcal{J}$. This function can be the composition $(g \circ f)(z) = g(f(z))$.
                        $(g \circ f)$ is poly-time as $f$ and $g$ are poly-time.
                \end{descriptionlist}
            \end{proof}
        \end{theorem}

    \item[\NP-hard] \marginnote{\NP-hard}
        Given a language $\mathcal{H} \in \{0, 1\}^*$, $\mathcal{H}$ is \NP-hard iff:
        \[ \forall \mathcal{L} \in \NP: \mathcal{L} \leq_p \mathcal{H} \]
    
    \item[\NP-complete] \marginnote{\NP-complete}
        Given a language $\mathcal{H} \in \{0, 1\}^*$, $\mathcal{H}$ is \NP-complete iff:
        \[ \mathcal{H} \in \NP \text{ and } \mathcal{H} \text{ is \NP-hard} \]
\end{description}

\begin{theorem}
    \phantom{}
    \begin{enumerate}
        \item\label{th:np_hard_p} If $\mathcal{L}$ is \NP-hard and $\mathcal{L} \in \P$, then $\P = \NP$.
        \item If $\mathcal{L}$ is \NP-complete, then $\mathcal{L} \in \P \iff \P = \NP$.
    \end{enumerate}

    \begin{proof}
        \phantom{}
        \begin{enumerate}
            \item Let $\mathcal{L}$ be \NP-hard and $\mathcal{L} \in \P$.
                We want to prove that $\P = \NP$:
                \begin{descriptionlist}
                    \item[$\P \subseteq \NP$)] Proved in \Cref{th:P_NP_EXP_relationship}.
                    \item[$\NP \subseteq \P$)]
                        Let $\mathcal{H}$ be a language in $\NP$.
                        As $\mathcal{L}$ is \NP-hard, by definition it holds that $\mathcal{H} \leq_p \mathcal{L}$.
                        Moreover, by hypothesis, it holds that $\mathcal{L} \in \P$. 
                        Therefore, we can conclude that $\mathcal{H} \in \P$ as it can be reduced to a language in $\P$.
                \end{descriptionlist}

            \item Let $\mathcal{L}$ be \NP-complete.
                We want to prove that $\mathcal{L} \in \P \iff \P = \NP$:
                \begin{descriptionlist}
                    \item[$(\mathcal{L} \in \P) \Rightarrow (\P = \NP)$)] 
                        Trivial for \hyperref[th:np_hard_p]{Point 1} as $\mathcal{L}$ is also \NP-hard.
                    \item[$(\mathcal{L} \in \P) \Leftarrow (\P = \NP)$)] 
                        Let $\P = \NP$.
                        As $\mathcal{L}$ is \NP-complete, it holds that 
                        $\mathcal{L} \in \NP=\P$.
                \end{descriptionlist}
        \end{enumerate}        
    \end{proof}
\end{theorem}

\begin{theorem}
    The problem \texttt{TMSAT} of simulating any TM is \NP-complete:
    \[ \texttt{TMSAT} = \{ (\alpha, x, 1^n, 1^t) \mid \exists u \in \{0, 1\}^n: \mathcal{M}_\alpha(x, u) = 1 \text{ within $t$ steps} \} \]
\end{theorem}

\begin{theorem}[Cook-Levin] \marginnote{Cook-Levin theorem}
    The following languages are \NP-complete:
    \[
        \begin{split}
            \texttt{SAT}  &= \{ \enc{F} \mid F \text{ is a satisfiable CNF} \} \\
            \texttt{3SAT} &= \{ \enc{F} \mid F \text{ is a satisfiable 3CNF} \} \\
        \end{split}  
    \]
\end{theorem}